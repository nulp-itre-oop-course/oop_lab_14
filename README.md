# Робота з лінійним однозв’язним списком
**Мета:** отримати практичні навички роботи з динамічними структурами даних у C++ — написати, відлагодити та протестувати програму, у якій реалізувати основні операції з однозв'язним списком.

## Вказівки до роботи
Відповідно до цієї інструкції вам потрібно у середовищі Visual Studio Code з використанням набору компіляторів GCC створити програму мовою C++ для обробки даних з використанням лінійного однозв’зного списку.

Також реалізувати відповідні класи, конструктори, деструктори, методи. Потрібно реалізувати багатофайловий проєкт у середовищі Visual Studio Code з описом кожного класу у відповідних парах заголовного та виконуваного файлів.

## Завдання:
1.	Вибрати завдання згідно свого варіанту у **ДОДАТКУ**.
2.	Реалізувати клас, який представляє однозв'язний список. Елементами списку може бути клас або структура.
3.	Список повинен підтримувати наступні основні операції:
-	Створення базового класу для елемента списку.
-	Додавання елемента (на початок списку, на кінець списку, у вказану позицію після певного елемента).
-	Видалення елемента (з початку списку, з кінця списку, за значенням елемента).
-	Виведення елементів списку послідовно.
-	Перевірка чи елемент списку порожній.
-	Коректне видалення всіх вузлів списку при знищенні об'єкта.

### Короткі відомості
Однозв'язний список — це лінійна динамічна структура даних, яка складається з послідовності елементів, що називаються вузлами (Nodes). Кожен вузол містить:
- Дані (Data) — безпосередньо інформацію, яку зберігає вузол (наприклад, ціле число, рядок або об'єкт).
- Вказівник (Pointer/Link) — посилання на наступний вузол у послідовності.
Список вважається однозв'язним, оскільки перехід можливий лише в одному напрямку: від поточного вузла до наступного. Останній вузол у списку завжди містить нульовий вказівник (`nullptr`), що сигналізує про кінець послідовності.

Основні компоненти однозв’язного списку:
- Вузол (Node) — базовий елемент, що зберігає дані та посилання. Реалізується як `struct` або `class`.
- Голова (Head) — вказівник на перший вузол у списку. Необхідний для доступу до списку. Якщо Head є `nullptr`, список порожній.
- Хвіст (Tail) — вказівник на останній вузол у списку.
- Nullptr — значення вказівника, яке вказує на кінець списку. Вузли, чий вказівник next дорівнює `nullptr`, є останніми.
Перевагами однозв’язного списку є:
- Динамічний розмір — на відміну від статичних масивів, список може зростати або зменшуватися в пам'яті під час виконання програми.
- Ефективне вставлення/видалення — додавання або видалення елемента на початку списку або в середині (якщо відомий попередній елемент) відбувається дуже швидко, за константний час `O(1)`.
- Ефективне використання пам'яті — пам'ять виділяється лише тоді, коли потрібен новий елемент.
Недоліками однозв’язного списку можна назвати такі аспекти:
- Потрібна додаткова пам'ять — Кожен вузол зберігає не лише дані, а й вказівник, що збільшує загальні витрати пам'яті.
- Повільний прямий доступ — щоб отримати доступ до N-го елемента, необхідно почати з голови та послідовно пройти (N−1) вузол. Доступ до довільного елемента вимагає лінійного часу `O(n)`.
- Повільне видалення з кінця — для видалення останнього елемента необхідно знайти передостанній вузол, що також вимагає проходу всього списку `(O(n))`.

Приклад реалізації однозв’язного списку мовою С++:
```c++
#include <iostream>
#include <stdexcept> // Для обробки винятків

// Створення вузла (Node)
struct Node {
    int data;     // дані, що зберігаються у вузлі
    Node* next;   // вказівник на наступний вузол
    // Конструктор
    Node(int val) : data(val), next(nullptr) {}
};

// Клас однозв'язного списку
class LinkedList {
private:
    Node* head; // вказівник на початок списку (голову)

public:
    // Конструктор: Ініціалізує список як порожній
    LinkedList() : head(nullptr) {}
    // Деструктор - очищає всю пам'ять, виділену для списку
    ~LinkedList() {
        Node* current = head;
        while (current != nullptr) {
            Node* next = current->next;
            delete current;
            current = next;
        }
        head = nullptr;
    }
    // Перевірка чи порожній елемент
    bool is_empty() const {
        return head == nullptr;
    }
    // Додавання на початок
    void push_front(int val) {
        Node* new_node = new Node(val);
        new_node->next = head;
        head = new_node;
        std::cout << "Додано " << val << " на початок." << std::endl;
    }
    // Додавання в кінець
    void push_back(int val) {
        Node* new_node = new Node(val);
        if (is_empty()) {
            head = new_node;
        } else {
            Node* current = head;
            // Переходимо до останнього вузла
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = new_node;
        }
        std::cout << "Додано " << val << " на кінець." << std::endl;
    }
    // Видалення з початку
    int pop_front() {
        if (is_empty()) {
            throw std::out_of_range("Список порожній, неможливо видалити з початку.");
        }
        Node* temp = head;
        int val = temp->data;
        head = head->next; // Пересуваємо голову на наступний елемент
        delete temp;       // Звільняємо пам'ять видаленого вузла
        return val;
    }
    // Видалення з кінця
    int pop_back() {
        if (is_empty()) {
            throw std::out_of_range("Список порожній, неможливо видалити з кінця.");
        }
        // Обробка випадку, коли в списку лише один елемент!
        if (head->next == nullptr) { // Якщо лише один елемент
            int val = head->data;
            delete head;
            head = nullptr;
            return val;
        }
        Node* current = head;
        // Знаходимо передостанній вузол
        while (current->next->next != nullptr) {
            current = current->next;
        }
        Node* temp = current->next; // Останній вузол
        int val = temp->data;
        current->next = nullptr;    // Передостанній стає останнім
        delete temp;
        return val;
    }
    // Виведення списку
    void display() const {
        if (is_empty()) {
            std::cout << "Список порожній." << std::endl;
            return;
        }
        Node* current = head;
        std::cout << "Список: ";
        while (current != nullptr) {
            std::cout << current->data;
            if (current->next != nullptr) {
                std::cout << " -> ";
            }
            current = current->next;
        }
        std::cout << std::endl;
    }
};
```

### Оформлення звіту
У звіті студент має вказати свій варіант індивідуального завдання та представити:
1.	Блок-схему алгоритму програми.
2.	Код (лістинг) програми.
3.	Результати тестування для різних вхідних умов.
4.	Конструктивний висновок — що ви дізналися нового, чого навчилися, якими способами та інструментами досягнули мети.

## ДОДАТОК

### Варіанти завдань

|  № |              Клас             |                              Поля класу                                 |
|----|-------------------------------|-------------------------------------------------------------------------|
|  1 | Резистор                      | Номінальний опір, максимальна потужність розсіяння, клас точності       |
|  2 | Конденсатор                   | Номінальна ємність, максимальна напруга, тип матеріалу                  |
|  3 | Транзистор                    | Тип, коефіцієнт підсилення, максимальний струм                          |
|  4 | Діод                          | Пряма напруга, максимальний зворотний струм, призначення                |
|  5 | Операційний підсилювач        | Коефіцієнт підсилення, напруга живлення, кількість входів               |
|  6 | Котушка індуктивності         | Індуктивність, опір, кількість витків                                   |
|  7 | Радіопередавач                | Робоча частота, потужність, тип модуляції                               |
|  8 | Антена                        | Тип, коефіцієнт підсилення, частотний діапазон                          |
|  9 | Радіоприймач                  | Робоча частота, чутливість, тип модуляції                               |
| 10 | Осцилограф                    | Кількість каналів, смуга пропускання, тип (аналоговий/цифровий)         |
| 11 | Акумулятор                    | Ємність, напруга, тип матеріалу                                         |
| 12 | Мікросхема                    | Назва/маркування, кількість виводів, напруга живлення                   |
| 13 | Коаксіальний кабель           | Хвильовий опір, діаметр, довжина                                        |
| 14 | Датчик температури            | Тип, діапазон вимірювання, точність                                     |
| 15 | Друкована плата               | Ширина, довжина, кількість шарів                                        |
| 16 | Світлодіод                    | Колір, робочий струм, напруга                                           |
| 17 | Оптоволоконний кабель         | Кількість волокон, тип, довжина                                         |
| 18 | Аналого-цифровий перетворювач | Розрядність, частота дискретизації, кількість каналів                   |
| 19 | Мікроконтролер                | Архітектура, частота, кількість портів                                  |
| 20 | Радіореле                     | Напруга котушки, максимальний струм комутації, кількість груп контактів |
| 21 | Акустичний динамік            | Опір, потужність, діаметр                                               |
| 22 | Трансформатор                 | Коефіцієнт трансформації, первинна напруга, потужність                  |
| 23 | Генератор сигналів            | Тип сигналу, максимальна частота, наявність модуляції                   |
| 24 | Атенюатор                     | Коефіцієнт послаблення, максимальна потужність, тип                     |
| 25 | Електронний фільтр            | Тип, частота зрізу, порядок                                             |
| 26 | Телевізор                     | Діагональ екрану, роздільна здатність, наявність Smart-TV               |
| 27 | Супутник зв’язку              | Тип орбіти, кількість транспондерів, частотний діапазон                 |
| 28 | Роутер                        | Швидкість передавання даних, стандарт WiFi, кількість портів LAN        |
| 29 | Сигналізація                  | Кількість датчиків, наявність бездротових сенсорів, спосіб оповіщення   |
| 30 | Ретранслятор                  | Коефіцієнт підсилення, тип, робоча частота                              |
